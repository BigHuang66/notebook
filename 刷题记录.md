# 链表



# 二叉树

#### 894.所有可能的满二叉树 

https://leetcode-cn.com/problems/all-possible-full-binary-trees/

| 3.1    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 看答案 |      |      |      |      |      |

3.1 本题最开始拿到时，考虑的方法是利用DFS来进行回溯，但是结果发现回溯时，每次撤销导致有情况丢失。看答案如下，本质还是递归，不过用了排列组合的思想：

```c++
class Solution {
public:
    vector<TreeNode*> allPossibleFBT(int N) {
        vector<TreeNode*> temp;
        if (N == 0) return temp;
        if (N % 2 == 0)  return temp;
        if (N == 1) {
            temp.push_back(new TreeNode(0));
            return temp;
        }
        // 分别分奇数构建左右子树
        for (int i = 1; i < N-1; i+=2) {
            vector<TreeNode*> left = allPossibleFBT(i);
            vector<TreeNode*> right = allPossibleFBT(N-1-i);
			// 排列组合
            for (int i = 0; i < left.size(); ++i)
                for (int j = 0; j < right.size(); ++j) {
                    TreeNode* node = new TreeNode(0);
                    node->left = left[i];
                    node->right = right[j];
                    temp.push_back(node);
                    
                }
        }
        return temp;
    }
};
```







#### 1123.最深叶结点的最近公共祖先

https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/

| 3.1                                  |      |      |      |      |      |
| ------------------------------------ | ---- | ---- | ---- | ---- | ---- |
| 自己做出来，和答案不同，答案更为巧妙 |      |      |      |      |      |

3.1 先分两步，首先找到最深叶结点，利用BFS；其找到这些节点的最近公共祖先，参考之前写的找到最近公共祖先的题

```c++
class Solution {
public:
// 先分两步，首先找到最深叶结点，利用BFS；其找到这些节点的最近公共祖先
    TreeNode* lcaDeepestLeaves(TreeNode* root) {
        if (root == nullptr)    return nullptr;
        queue<TreeNode*> q, copy;
        q.push(root);
        while (!q.empty()) {
            copy = queue(q);
            int size = q.size();
            while (size--) {
                TreeNode* node = q.front();
                q.pop();
                if (node->left) q.push(node->left);
                if (node->right)    q.push(node->right);
            }
        }
        unordered_map<TreeNode*, int> dict;
        while(!copy.empty()) {
            dict[copy.front()]++;
            copy.pop();
        }
        return lowestCommonAncestor(root, dict);
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, unordered_map<TreeNode*, int>& dict) {
        if (root == nullptr)    return nullptr;
        if (dict.count(root))   return root;

        TreeNode* left = lowestCommonAncestor(root->left, dict);
        TreeNode* right = lowestCommonAncestor(root->right, dict);
        if (left == nullptr)    return right;
        if (right == nullptr)   return left;
        return root;
    }
};
```

更为清晰的方法，最深叶结点的祖先具有的特点，左右子树高度相等，如果不等，说明结果在高的子树里面：

```c++
class Solution {
public:
    TreeNode* lcaDeepestLeaves(TreeNode* root) {
        if (root == nullptr)    return nullptr;
        int left = len_tree(root->left);
        int right = len_tree(root->right);

        if (left == right) 
            return root;
        else if (left > right)
            return lcaDeepestLeaves(root->left);
        else    
            return lcaDeepestLeaves(root->right);
    }

    int len_tree(TreeNode* root) {
        if (root == nullptr)    return 0;
        return max(len_tree(root->left), len_tree(root->right)) + 1;
    }
};
```

此时存在多次重复计算子树深度的问题，将递归求解与递归求高度融合一起.





#### 1315.最深叶结点的最近公共祖先

https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/

| 3.1        |      |      |      |      |      |
| ---------- | ---- | ---- | ---- | ---- | ---- |
| 自己做出来 |      |      |      |      |      |

3.1 祖父节点，其实也就是看 值为偶数的节点的孙子节点 是否存在 孙子节点有四个

```c++
class Solution {
public:
// 祖父节点，其实也就是看 值为偶数的节点的孙子节点 是否存在 孙子节点有四个
    int sumEvenGrandparent(TreeNode* root) {
        int val_sum = 0;
        dfs(root, val_sum);
        return val_sum;
    }

    void dfs(TreeNode* root, int& val_sum) {
        if (root == NULL) return;
        
        if (root->val % 2 == 0) {
            if (root->left) {
                if (root->left->left)   val_sum += root->left->left->val;
                if (root->left->right)   val_sum += root->left->right->val;
            }
            if (root->right) {
                if (root->right->left)   val_sum += root->right->left->val;
                if (root->right->right)   val_sum += root->right->right->val;
            }   
        }
 
        if (root->left)     dfs(root->left, val_sum);
        if (root->right)    dfs(root->right, val_sum);

    }
};
```





#### 235.二叉搜索树的最近公共祖先

https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |

与后面一题的区别，此处借助二叉搜索的特点，就更能找到p、q的分布

后面一题则需要不断后续遍历的方式，找到对应的节点在哪，并不断返回直到出现分布符合不在同一侧的情况。

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL)   return NULL;
        if (p->val > root->val && q->val > root->val)
            return lowestCommonAncestor(root->right, p, q);
        else if (p->val < root->val && q->val < root->val)
            return lowestCommonAncestor(root->left, p, q);
        else
            return root; // 分散两边 或者 出现p、q其中一个在root上，另一个在左、右子树 
        
    }
};
```



#### 236.二叉树的最近公共祖先

https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |

见上一题对比。一般二叉树无法预知节点的分布，故不能采用二叉搜索树中不断逼近的方法，此时只能遍历来找值，一旦找到就不断返回节点的指针，根据两个指针在树中的位置来判断关系。同侧时，找到在上面的节点。不同侧时找到最近的公共节点。

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL)   return NULL;
        if (root->val == p->val || root->val == q->val) return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left == NULL)   return right;
        if (right == NULL)  return left;
        return root;
        
    }
};
```





#### 96.不同的二叉搜索树

https://leetcode-cn.com/problems/unique-binary-search-trees/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |

这一题与下面一题类似，但是这题没有必要遍历路径，相对的，可以由下一题实际遍历的思路来直接计算结果。相反，也可以用本题来指导下一题

找到关系后，应该看出来是有重复子问题的，故使用动态规划

![image-20210301203342725](https://cdn.jsdelivr.net/gh/BigHuang66/picBed@main/img/20210301203342.png)

```c++
class Solution {
public:
// 利用中间节点进行分割找到关系，利用动态规划分别来求
    int numTrees(int n) {
        vector<int> dp = vector<int>(n+1, 0);
        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2; i <= n; ++i)
            for (int j = 1; j <= i; ++j)
                dp[i] += dp[j-1]*dp[i-j];

        return dp[n];
    }
};
```





#### 97.不同的二叉搜索树II

https://leetcode-cn.com/problems/unique-binary-search-trees-ii/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |



```c++
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        return buildTree(1, n);
    }

    vector<TreeNode*> buildTree(int left, int right) {
        if (left > right)
            return {nullptr};
        vector<TreeNode*> temp;
        for (int i = left; i <= right; ++i) {
            vector<TreeNode*> left_list = buildTree(left, i-1);
            vector<TreeNode*> right_list = buildTree(i+1, right);

            for (auto& left: left_list)
                for (auto& right: right_list) {
                    TreeNode* node = new TreeNode(i);
                    node->left = left;
                    node->right = right;
                    temp.emplace_back(node);
                }
        }
        return temp;
    }
};
```





#### 919.完全二叉树插入器

https://leetcode-cn.com/problems/complete-binary-tree-inserter/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |

这种题目一般都是借用成熟的数据结构来构建，树的问题就在于需要递归比价来索引，无法直接得到，可以建立索引对应来完成。

从1开始存入节点，索引为n的节点，其左子节点索引为2n，右子节点索引为2n+1

```c++
class CBTInserter {
public:
// 这种题目一般都是借用成熟的数据结构来构建，树的问题就在于需要递归比价来索引，无法直接得到，可以建立索引对应来完成
    vector<TreeNode*> dict;
    CBTInserter(TreeNode* root) {
        dict.emplace_back(new TreeNode(0));
        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            int size = q.size();
            while(size--) {
                TreeNode* node = q.front();
                dict.emplace_back(node);
                q.pop();
                if (node->left)     q.push(node->left);
                if (node->right)    q.push(node->right);
            }
        }
    }
    
    int insert(int v) {
        TreeNode* node = new TreeNode(v);
        dict.emplace_back(node);
        int index = dict.size() - 1;
        int f_index = index / 2;
        if (index % 2)
            dict[f_index]->right = node;
        else
            dict[f_index]->left = node;
        return dict[f_index]->val;
    }
    
    TreeNode* get_root() {
        if (dict.size() == 1) // 此题可以不加，加上防止索引为空时索引溢出
            return NULL;
        return dict[1];
    }
};
```





# 区间问题



#### 56.合并区间

https://leetcode-cn.com/problems/merge-intervals/

| 3.2      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 自己做的 |      |      |      |      |      |

先排序，可以考虑下有没有必要排序第二个元素。维护一个最长区间，依次拿区间进行对比，分析清楚包含、相交、分离的三种情况。

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> ans;
        sort(intervals.begin(), intervals.end());

        vector<int> max_inter = intervals[0];
        for (int i = 1; i < intervals.size(); ++i) {
            // if (max_inter[1] >= intervals[i][1])
            //     continue;
            if (max_inter[1] >= intervals[i][0] && max_inter[1] < intervals[i][1]) // 第二个字符可以不排序，包含在这里
                max_inter[1] = intervals[i][1];
            else if (max_inter[1] < intervals[i][0]) {
                ans.push_back(max_inter);
                max_inter = intervals[i];
            }
        }
        ans.push_back(max_inter);
        return ans;

    }
};
```





#### 57.插入区间

[57. 插入区间 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/insert-interval/)

| 3.2      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参考答案 |      |      |      |      |      |

 最笨的方法：相当于按照56题的，插入以及重新排序

 优化的方法：抓住原本无重叠且有序，根据插入的区间来选择合适的插入位置，减少排序消耗

![image-20210302151338779](https://cdn.jsdelivr.net/gh/BigHuang66/picBed@main/img/20210302151338.png)

```c++
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        vector<vector<int>> ans;
        
        int i = 0;
        int size = intervals.size();
        // 在待插入区间左边的 只看待插入左边界
        while (i < size && intervals[i][1] < newInterval[0]) {
            ans.push_back(intervals[i]);
            i++;
        }
		// 与待插入区间存在交叉区域 只看待插入右边界
        while (i < size && intervals[i][0] <= newInterval[1]) {
            newInterval[0] = min(newInterval[0], intervals[i][0]);
            newInterval[1] = max(newInterval[1], intervals[i][1]);
            i++;
        }
        ans.push_back(newInterval);
		// 待插入区间右边的
        while (i < size) {
            ans.push_back(intervals[i]);
            i++;
        }
        return ans;
    }
};
```







#### 1288.删除被覆盖区间

[1288. 删除被覆盖区间 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/remove-covered-intervals/)

| 3.2      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参考答案 |      |      |      |      |      |

和上面题目类似思路，但是直接累计结果就好了，注意排序得首位从小到大，末尾从大到小的方式，这样不会丢失被覆盖的区间，当区间完全被覆盖时count++



```c++
class Solution {
public:
    static bool compare(vector<int>& a, vector<int>& b) {
        if (a[0] == b[0])
            return a[1] > b[1];
        return a[0] < b[0];
    }

    int removeCoveredIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), compare);

        int remove = 0;
        vector<int>& max_inter = intervals[0];
        for(int i = 1; i < intervals.size(); ++i) {
            if (intervals[i][1] <= max_inter[1])
                remove++;
            else if (max_inter[1] >= intervals[i][0] && max_inter[1] < intervals[i][1])
                max_inter[1] = intervals[i][1];
            else if (max_inter[1] < intervals[i][0])
                max_inter = intervals[i];
        }
        return intervals.size()-remove;
    }
};
```





#### 288.汇总区件

[228. 汇总区间 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/summary-ranges/)

| 3.2    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 自己做 |      |      |      |      |      |

遍历更新就好了

```c++
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        if (nums.empty())   return {};

        vector<string> ans;
        vector<int> inter(2, nums[0]);

        for(int i = 0; i < nums.size()-1; ++i) {
            if (nums[i] + 1 == nums[i+1])
                inter[1] = nums[i+1];
            else {
                if (inter[0] == inter[1])
                    ans.emplace_back(to_string(inter[0]));
                else
                    ans.emplace_back(to_string(inter[0]) + "->" + to_string(inter[1]));
                inter[0] = nums[i+1];
                inter[1] = nums[i+1];
            }
        }
        if (inter[0] == inter[1])
            ans.emplace_back(to_string(inter[0]));
        else
            ans.emplace_back(to_string(inter[0]) + "->" + to_string(inter[1]));
        return ans;
    }
};
```





#### 986.区间列表的交集

[986. 区间列表的交集 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/interval-list-intersections/)

|      | 3.2          |      |      |      |      |
| ---- | ------------ | ---- | ---- | ---- | ---- |
|      | 参考历史记录 |      |      |      |      |

有点NMS的意味，分别各拿一个，算重合区间，存在则记录，否则看谁长，选短的那一端递增。

```c++
class Solution {
public:
    vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList, vector<vector<int>>& secondList) {
        vector<vector<int>> ans;
        int size1 = firstList.size(), size2 = secondList.size();
        int i = 0, j = 0;
        while (i < size1 && j < size2) {
            vector<int>& a = firstList[i];
            vector<int>& b = secondList[j];
            int left = max(a[0], b[0]);
            int right = min(a[1], b[1]);
            if (right - left >= 0)
                ans.emplace_back(vector<int>{left, right});
                // cout << left << right << endl;
            if (b[1] > a[1])
                i++;
            else
                j++;
        }
        return ans;
    }
};
```





#### 435.无重叠区间

[435. 无重叠区间 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/non-overlapping-intervals/)

| 3.2          |      |      |      |      |      |
| ------------ | ---- | ---- | ---- | ---- | ---- |
| 参考历史记录 |      |      |      |      |      |

贪心算法，有重合时应该尽量去除右边界长的（保留右边界小的）。

```c++
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.empty())  return 0;

        sort(intervals.begin(), intervals.end());
        int end = intervals[0][1];
        int count = 0;
        
        for(int i = 1; i < intervals.size(); ++i) {
            if (intervals[i][0] < end) {
                end = min(intervals[i][1], end);
                count++;
            } else
                end = intervals[i][1];
        }
        return count;
    }
};
```







#### 795.区间子数组个数

[795. 区间子数组个数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum/)

| 3.2      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 看答案的 |      |      |      |      |      |

首先是组合的数目采用 前N项和计算；其次是利用集合相减的方式来计算中间集合的大小。

```c++
class Solution {
public:
    int numSubarrayBoundedMax(vector<int>& A, int L, int R) {
        return countN(A, R) - countN(A, L-1);
    }

    int countN(vector<int>& A, int T) {
        int count = 0;
        int value = 0;
        for (int n:A) {
            value = n <= T ? value+1 : 0;
            count += value;
        }
        return count;
    }
};
```









# 回溯算法

## 总结：

```python
#**************************** 回溯算法框架 ***********************************

# ** 注意回溯 实际问题要适当 剪枝减低计算量；要经常结合树图分析**
	result = []
    def backtrack(路径, 路径列表):
        if 满足结束条件:
            result.add(路径)
            return
        # 做选择
        路径.add()
        # 遍历
        backtrack(路径, 路径列表)
       	# 撤销选择
        路径.del()
```

具体可能遇到以下问题：

![](https://cdn.jsdelivr.net/gh/BigHuang66/picBed@main/img/20210303112953.svg)



#### 39.组合总和

[39. 组合总和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/combination-sum/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 看答案 |      |      |      |      |      |

首先求解目标和 target的问题，注意用减法，避免引入 加法做和 

其次得注意这是组合问题，参照组合问题特性解决。

本题可以重复使用元素，维护begin，每次从 i 开始做选择就好，这时包含了本身

本类型题目注意剪枝，明确不满足条件没必要带入递归当中，但是注意本题要想直接break，需要先排序

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<int> path;
        sort(candidates.begin(), candidates.end());
        backtrack(candidates, 0, target, path);
        return ans;

    }

    void backtrack(vector<int>& candidates, int begin, int target, vector<int>& path) {
        if (target == 0) {
            ans.emplace_back(path);
            return;
        } else if (target < 0)
            return;
        // 做选择
        for (int i = begin; i < candidates.size(); ++i) {
            if (target-candidates[i] < 0) // 剪枝，因为已经排序了，前面为负，后面肯定更是
                break;
            path.push_back(candidates[i]);
            backtrack(candidates, i, target-candidates[i], path);
            path.pop_back();
        }       
    }
};
```







#### 40.组合总和 II

[40. 组合总和 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/combination-sum-ii/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 看答案 |      |      |      |      |      |

39题基础上，元素只能使用一次，存在重复元素等两个问题，可以按照思维导图分别实现。

只能使用一次的问题，使用begin = i + 1实现就好；重复元素问题 排序、维护visited、if (i>0 && !visited[i] && nums[i] == nums[i-1])

```c++
class Solution {
public:
// 这一题相对于 39题 多了重复元素的问题，可以先排序+visited解决
    vector<vector<int>> ans;
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<int> path;
        vector<bool> visited(candidates.size(), false);
        sort(candidates.begin(), candidates.end());
        backtrack(candidates, visited, 0, target, path);
        return ans;

    }

    void backtrack(vector<int>& candidates, vector<bool>& visited, int begin, int target, vector<int>& path) {
        if (target == 0) {
            ans.emplace_back(path);
            return;
        } else if (target < 0)
            return;
        
        for (int i = begin; i < candidates.size(); ++i) {
            if (target - candidates[i] < 0) // 剪枝
                break;
            // if (visited[i] == true) // 此处与下面i+1 相对，原理都为避免范围重复元素 选一个即可
            //     continue;
            if (i > 0 && !visited[i-1] && candidates[i] == candidates[i-1])
                continue;
            
            visited[i] = true;
            path.push_back(candidates[i]);
            backtrack(candidates, visited, i+1, target-candidates[i], path);
            visited[i] = false;
            path.pop_back();
        }
    }
};
```









#### 216.组合总和 III

[216. 组合总和 III - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/combination-sum-iii/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 看答案 |      |      |      |      |      |

这一题似乎是个九叉树的问题，开始被 k 弄晕，本以为要循环3次，每次从1~9中间取值......最后发现完全可以直接遍历1~9 直到 path长度等于 k 就好了，从终止条件来约束遍历的过程。

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<int> path;
        vector<bool> visited(k, false);
        backtrack(k, n, 1, visited, path);
        return ans;
    }

    void backtrack(int k, int n, int begin, vector<bool>& visited, vector<int>& path) {
        if (n == 0 && path.size() == k) {
            ans.emplace_back(path);
            return;
        } else if (n < 0)
            return;

        for (int i = begin; i <= 9; ++i) {
            if (n - i < 0)  break;
            if (visited[i-1])
                continue;
            path.push_back(i);
            visited[i-1] = true;
            backtrack(k, n-i, i, visited, path);
            path.pop_back();
            visited[i-1] = false;
        }
    }
};
```









#### 78.子集

[78. 子集 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/subsets/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 看答案 |      |      |      |      |      |

子集问题，避免排列重复的情况，引入begin来限制 做选择 的起点。同时做一次选择就可以视为一个子集读入，注意空集合也是子集。

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<int> path;
        ans.push_back({});
        backtrack(nums, 0, path);
        return ans;
    }

    void backtrack(vector<int>& nums, int begin, vector<int>& path) {
        if (begin == nums.size()) {
            return;
        }

        for (int i = begin; i < nums.size(); ++i) {
            path.push_back(nums[i]);
            ans.emplace_back(path);
            backtrack(nums, i+1, path);
            path.pop_back();
        }
    }
};
```







#### 90.子集 II

[90. 子集 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/subsets-ii/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 看答案 |      |      |      |      |      |

可能包含重复元素的子集问题，在子集问题基础上剪枝，主要剪掉重复元素的问题。维护visited，使用 if (i >0 && !visited[i-1] && nums[i]==nums[i-1]) 

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<int> path;
        vector<bool> visited(nums.size(), false);
        ans.push_back({});
        sort(nums.begin(), nums.end());
        backtrack(nums, visited, 0, path);
        return ans;
    }

    void backtrack(vector<int>& nums, vector<bool>& visited, int begin, vector<int>& path) {
        if (begin == nums.size())
            return;
        
        for (int i = begin; i < nums.size(); ++i) {
            if (i > 0 && !visited[i-1] && nums[i] == nums[i-1])
                continue;
            path.push_back(nums[i]);
            visited[i] = true;
            ans.emplace_back(path);
            backtrack(nums, visited, i+1, path);
            path.pop_back();
            visited[i] = false;
        }
    }
};
```







#### 46.全排列

[46. 全排列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/permutations/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 自己做 |      |      |      |      |      |

全排列问题，每一层从头做选择，但是需要维护 visited 来防止重复元素

```c++
// 全排列问题用回溯算法解决
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> permute(vector<int>& nums) {
        vector<int> path;
        vector<bool> visited(nums.size(), false);
        backtrack(nums, visited, path);
        return ans;
    }
    void backtrack(vector<int>& nums, vector<bool>& visited, vector<int>& path) {
        // 结束条件
        if (path.size() == nums.size()) {
            ans.emplace_back(path);
            return ;
        }

        for (int i = 0; i < nums.size(); ++i) {
            // nums[i] already visited, then continue
            if (visited[i])
                continue;
            path.push_back(nums[i]);
            visited[i] = true;
            backtrack(nums, visited, path);
            path.pop_back();
            visited[i] = false;
        }

    }
};
```







#### 47.全排列 II

[47. 全排列 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/permutations-ii/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 自己做 |      |      |      |      |      |

包含重复元素的全排列问题，维护 visited 和 if(i>0 && !visited[i-1] && nums[i] == nums[i-1])

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<int> path;
        vector<bool> visited(nums.size(), false);
        sort(nums.begin(), nums.end());
        backtrack(nums, visited, path);
        return ans;
    }

    void backtrack(vector<int>& nums, vector<bool>& visited, vector<int>& path) {
        if (path.size() == nums.size()) {
            ans.emplace_back(path);
            return;
        }

        for (int i = 0; i < nums.size(); ++i) {
            if (visited[i])
                continue;
            
            if (i > 0 && !visited[i-1] && nums[i]==nums[i-1])
                continue;
            path.push_back(nums[i]);
            visited[i] = true;
            backtrack(nums, visited, path);
            path.pop_back();
            visited[i] = false;
        }
    }
};
```









#### 131.分割回文串

[131. 分割回文串 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/palindrome-partitioning/)

| 3.3      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参考档案 |      |      |      |      |      |

利用 begin 和 i 类似于作为双指针的方式来不断截取字符串，重点是终止条件

```c++
class Solution {
public:
    vector<vector<string>> ans;
    vector<vector<string>> partition(string s) {
        vector<string> path;
        backtrack(s, 0, path);
        return ans;
    }
    void backtrack(string& s, int begin, vector<string>& path) {
        if (begin == s.size()) {
            ans.emplace_back(path);
            return;
        }

        for (int i = begin; i < s.size(); ++i) {
            if (!check(s, begin, i))
                continue;
            path.emplace_back(s.substr(begin, i-begin+1));
            backtrack(s, i+1, path);
            path.pop_back();
        }
    }

    bool check(string& s, int left, int right) {
        while (left < right) {
            if (s[left] != s[right])
                return false;
            left++;
            right--;
        }
        return true;
    }
};
```









#### 93.复原IP地址

[93. 复原 IP 地址 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/restore-ip-addresses/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 自己做 |      |      |      |      |      |

和上一题有点像的，其实也属于字符串的分段，不够得加好剪枝与合法性判断

```c++
class Solution {
public:
    vector<string> ans;
    vector<string> restoreIpAddresses(string s) {
        string path;
        backtrack(s, 0, 0, path);
        return ans;
    }

    void backtrack(string& s, int begin, int section, string& path) {
        if (path.size() == s.size() + 4 && section == 4) { // 所得长度刚好为s+4(4个点) 且分区必须满足 4
            path.pop_back();                               // 可以不需要 == 4 之前已经被剪枝了，不可能满足长度相等情况下还分区不同。
            ans.emplace_back(path);                        // 如果没有对分区剪枝，可能会出现许多小数点填补导致长度相等
            return;
        }

        for (int i = begin; i < s.size(); ++i) {
            if (section > 3) // 分片超过四个了，剪枝
                break;
            if (i-begin >= 1 && s[begin] == '0') // 长度(i-begin+1) 大于一个，且以0开头，如果出现，后面必不可得到，剪枝  
                break;
            if (stoi(s.substr(begin, i-begin+1)) > 255) // 分片数值大于255， 剪枝
                break;
            
            string temp = path;                         // 便于撤销选择
            path += (s.substr(begin, i-begin+1) + ".");
            backtrack(s, i+1, section+1, path);
            path = temp;
        }
    }
};
```







# 动态规划

## 总结：

1、一般形式  ：求最值

2、核心问题  ：穷举、空间换时间

3、三要素  ： **`重叠子问题、最优子结构、状态转移方程`**

4、状态转移方程思维框架： 明确**状态**  ->  定义dp数组/函数的含义  ->  明确 **选择**  ->  明确 base case

```python
# 实际做题时，应该按照思考流程来，首先是 dp的定义，明确dp数组的含义非常重要，合理的定义能够帮助快速明确转移方程
# 在建立的定义上，寻找状态转移关系
# 寻找 base case 和 最终目标
# 完整构造程序
```



## 背包问题

总结来看：

- 找到背包问题的关键，选项与目标值（必要时需要转换问题）
- 确定是 0-1 背包 还是 完全背包
- 确定是 bool问题 ？最值问题 ？组合问题 ？
- 确定是组合问题还是排列问题

背包问题关键就是有多个选项，且有一个给给定目标值（或者通过转换问题得到），如果遇到物品只有一次选择机会为0-1背包问题，物体可重复多次选择的时候，为完全背包问题。针对0-1背包问题可以采用二维dp进行求解，再进行空间压缩的方式。针对完全背包，使用一维dp进行求解。嵌套循环设计时，物品在外面循环控制了物品选取的顺序性（不包含排列问题），物体是否可重复使用由转移方程中 i-1 还是 i 决定，i-1 表示已经针对最后一个做了决策，结果得依据之前的 i - 1 个物品了，但是 i 表示结果还是与 i 有关。

![背包问题](https://cdn.jsdelivr.net/gh/BigHuang66/picBed@main/img/20210308171724.svg)





#### 416.分割等和子集

https://leetcode-cn.com/problems/partition-equal-subset-sum/

| 3.8          |      |      |      |      |      |
| ------------ | ---- | ---- | ---- | ---- | ---- |
| 总结后自己做 |      |      |      |      |      |

这一题为 0-1背包中的bool问题，分成两个子集转换为某一组合的target为 sum / 2；可先用思路较为清晰的二维DP，后进行空间压缩

```c++
// 二维 DP
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (int num: nums)
            sum += num;
        if (sum % 2)    return false;
        int target = sum/2;
        int size = nums.size();
        vector<vector<bool>> dp(size+1, vector<bool>(target+1, false));
        dp[0][0] = true;
        for (int i = 1; i <= size; ++i) {
            for (int j = 0; j <= target; ++j) {
                if (j - nums[i-1] >= 0)
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]];
                else
                    dp[i][j] = dp[i-1][j];
            }
        }
        return dp[size][target];
    }
};

// 一维DP 空间压缩
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (int num: nums)
            sum += num;
        if (sum % 2)    return false;
        int target = sum/2;
        int size = nums.size();
        vector<bool> dp(target+1, false);
        dp[0] = true;
        for (int num: nums) {
            for (int j = target; j >= num; --j) {
                dp[j] = dp[j] || dp[j-num];
            }
        }
        return dp[target];
    }
};
```







#### 494.目标和

https://leetcode-cn.com/problems/target-sum/

| 3.8          |      |      |      |      |      |
| ------------ | ---- | ---- | ---- | ---- | ---- |
| 总结后自己做 |      |      |      |      |      |

这一题为 0-1背包中的组合问题，确定正数部分为 x，负数部分为 y。
$$
x+y = \sum num\\
x-y = S \\
Target = \frac{ \sum num + S}{2}
$$
此时定性为 0-1背包（直接一维DP），组合问题（nums在外循环）

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum = 0;
        for (int num: nums)
            sum += num;
        if (sum < S)    return 0;
        if ((S+sum) % 2)    return 0;
        
        int target = (S+sum)/2;
        vector<int> dp(target+1, 0);
        dp[0] = 1;
        for (int num: nums) {
            for (int j = target; j >= num; --j) {
                dp[j] += dp[j-num];
            }
        }
        return dp[target];
    }
};

```







#### 377.组合总和 Ⅳ

https://leetcode-cn.com/problems/combination-sum-iv/

| 3.8          |      |      |      |      |      |
| ------------ | ---- | ---- | ---- | ---- | ---- |
| 总结后自己做 |      |      |      |      |      |

比较明显的完全背包， 求解组合的数量的问题，但是涉及到了排列过程故将nums循环置内

```c++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target+1, 0);
        dp[0] = 1;
        for (int i = 0; i <= target; ++i) {
            for (int num: nums) {
                if (i - num >= 0 && dp[i] < INT_MAX-dp[i-num])
                    dp[i] += dp[i-num];
            }
        }
        return dp[target];
    }
};
```







#### 474.一和零

https://leetcode-cn.com/problems/ones-and-zeroes/

| 3.8          |      |      |      |      |      |
| ------------ | ---- | ---- | ---- | ---- | ---- |
| 总结后自己做 |      |      |      |      |      |

首先是 0-1背包问题，target为一个二维的数，求解最值问题（注意本题不是求解组合的个数问题，组合的个数一定是确定值，不存在什么最值问题，本题要求求解在 组合中元素个数最大值）

```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));

        for (string str: strs) {
            vector<int> count = countOnesZeros(str);
            for (int i = m; i >= count[0]; --i) {
                for (int j = n; j >= count[1]; --j) {
                    dp[i][j] = max(dp[i][j], dp[i-count[0]][j-count[1]] + 1);
                }
            }
        }
        return dp[m][n];
    }

    vector<int> countOnesZeros(string& s) {
        vector<int> count(2, 0);
        for (char c: s)
            count[c-'0']++;
        return count;
    }
};
```







#### 518.零钱兑换 II

https://leetcode-cn.com/problems/coin-change-2/

| 3.8          |      |      |      |      |      |
| ------------ | ---- | ---- | ---- | ---- | ---- |
| 总结后自己做 |      |      |      |      |      |

完全背包   ------> 内循环无需逆序

求解组合的个数（不允许排列） -----> nums在外

组合问题 -----> 存储组合的种数

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount+1, 0);
        dp[0] = 1;
        for (int coin: coins) {
            for (int j = coin; j <= amount; ++j)
                dp[j] += dp[j-coin];
        }
        return dp[amount];
    }
};
```





#### 139.单词拆分

https://leetcode-cn.com/problems/word-break/

| 3.8      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参考答案 |      |      |      |      |      |

这一题很奇怪，但是得转换思路

将字符串长度看成背包容量，子字符串看成商品，由于允许重复出现，为完全背包问题。 首先确定 dp[i] 含义为 s[0~i-1]字符串 满足条件与否。在s[0~i-1] 中 找到 j 拆分该串为s[0~j-1]   s[j~i-1] 两段，由于s[0~j-1] 的合法性早已经存储，需要计算 s[j~i-1] 的合法性（是否在dict中）如果两个条件满足，则 s[0~i-1] 满足条件，对应dp[i]=true，等加入下一个字符的时候，又是不断 分段来确定合法性，好在左边部分的合法性一直都在，不需要处理。

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> dict(wordDict.begin(), wordDict.end());
        int size = s.size();
        vector<bool> dp(size+1, false);
        dp[0] = true;
        for (int i = 1; i <= size; ++i) {
            for (int j = 0; j < i; ++j) {
                string str = s.substr(j, i-j);
                if (dp[j] && dict.count(str)) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[size];
    }
};
```























## 其它问题





#### 860.柠檬水找零

https://leetcode-cn.com/problems/lemonade-change/

| 3.5    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 自己做 |      |      |      |      |      |

这一题实际是使用贪心算法实现，但是可以类别后面的零钱找零问题

```c++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int five = 0, ten = 0; // 20的直接忽略，找不开
        int nums = 0;
        for (int bill: bills) {
            if (bill == 5)  five++;
            else if (bill == 10)    ten++;
            nums += bill;

            if (bill == 20) {
                if (ten >= 1 && five >= 1) {
                    ten--;
                    five--;
                } else if (five >= 3)
                    five -= 3;
                else
                    return false;
            }
            if (bill == 10) {
                if (five >= 1)
                    five--;
                else
                    return false;
            }
        }
        return true;
    }
};
```







#### 322.零钱兑换

https://leetcode-cn.com/problems/coin-change/

| 3.5      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参考答案 |      |      |      |      |      |

这一题实际是使用贪心算法实现，但是可以类别后面的零钱找零问题

```c++
// 动态规划
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int size = coins.size();
        vector<int> dp(amount+1, amount+1);
        dp[0] = 0;
        for (int i = 1; i <= amount; ++i) {
            for(int coin: coins) {
                if (i - coin < 0)   continue;
                dp[i] = min(dp[i], dp[i-coin]+1);
            }
        }
        return (dp[amount] == amount+1 ? -1: dp[amount]);
    }
};

// 回溯方法 + 记忆化搜索
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> memo(amount+1, 0);

        return backtrack(coins, amount, memo);
    }

    int backtrack(vector<int>& coins, int amount, vector<int>& memo) {
        if (amount == 0) {
            return 0;
        } else if (amount < 0)
            return -1;

        if (memo[amount] != 0) return memo[amount];
        int min = INT_MAX;
        for (int coin: coins) {
            int res = backtrack(coins, amount-coin, memo);
            if (res >= 0 && res < min)
                min = res + 1;
        }
        
        memo[amount] = (min == INT_MAX)? -1: min;
        return memo[amount];
    }
};
```









#### 10.正则表达式匹配

https://leetcode-cn.com/problems/regular-expression-matching/

| 3.6      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参考答案 |      |      |      |      |      |

可以用递归的方式来实现，或者使用动态规划，具体见代码

```c++
// 动态规划
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size()+1, n = p.size()+1;
        // dp[i][j] 表示 s[0~i-1] 与 p[0~j-1]的匹配结果 
        vector<vector<bool>> dp(m, vector<bool>(n, false));
		// 分析状态转移方程之后，需要确定边界条件，心里需要有这个想法
        // 第一列 除 第一个全是false
        // 第一行初始化，* 出现之前必须得有个字符，且利用 *消字符时，前面必须为True 防止ab*的情况
        dp[0][0] = true;
        for (int j = 1; j < n; ++j) {
            if (p[j-1] == '*' && dp[0][j-2])
                dp[0][j] = true;
        }
		// 按照转移方程来确定，但是需要注意一个地方就是索引问题，抓住 dp[i][j] 表示 s[0~i-1] 与 p[0~j-1]的匹配结果
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                if (p[j-1] == s[i-1] || p[j-1] == '.') {
                    dp[i][j] = dp[i-1][j-1];
                } else if (p[j-1] == '*') {
                    if (p[j-2] == s[i-1] || p[j-2] == '.')
                        dp[i][j] = dp[i][j-2] || dp[i-1][j];
                    else
                        dp[i][j] = dp[i][j-2];
                } else
                    dp[i][j] = false;
            }
        }
        // 终止边界
        return dp[m-1][n-1];
    }
};

// 回溯方法
class Solution {
public:
    bool isMatch(string s, string p) {
        vector<vector<bool>> memo(s.size()+1, vector<bool>(p.size()+1, false);
        return dp(s, p, 0, 0);

    }

    bool dp(string& s, string& p, int i, int j) {
        int m = s.size(), n = p.size();
        // 终止条件
        if (j == n)
            return i == m;
        if (i == m) {
            // 排除奇数的情况
            if ((n - j) % 2 == 1)
                return false;
            // 其实类似于动态规划中，dp的第一行，后续必须出现 字符* 成对出现才能消除
            for (; j+1 < p.size(); j += 2) {
                if (p[j+1] != '*')
                    return false;
            }
            return true;
        }

        if (s[i] == p[j] || p[j] == '.') {
            if (j < n-1 && p[j+1] == '*')
                return dp(s, p, i+1, j) || dp(s, p, i, j+2);
            else
                return dp(s, p, i+1, j+1);
        } else {
            if (j < n-1 && p[j+1] == '*')
                return dp(s, p, i, j+2);
            else
                return false;
        }

    }
};
```





