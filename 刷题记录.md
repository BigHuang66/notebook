# 链表



# 二叉树

#### 894.所有可能的满二叉树 

https://leetcode-cn.com/problems/all-possible-full-binary-trees/

| 3.1    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 看答案 |      |      |      |      |      |

3.1 本题最开始拿到时，考虑的方法是利用DFS来进行回溯，但是结果发现回溯时，每次撤销导致有情况丢失。看答案如下，本质还是递归，不过用了排列组合的思想：

```c++
class Solution {
public:
    vector<TreeNode*> allPossibleFBT(int N) {
        vector<TreeNode*> temp;
        if (N == 0) return temp;
        if (N % 2 == 0)  return temp;
        if (N == 1) {
            temp.push_back(new TreeNode(0));
            return temp;
        }
        // 分别分奇数构建左右子树
        for (int i = 1; i < N-1; i+=2) {
            vector<TreeNode*> left = allPossibleFBT(i);
            vector<TreeNode*> right = allPossibleFBT(N-1-i);
			// 排列组合
            for (int i = 0; i < left.size(); ++i)
                for (int j = 0; j < right.size(); ++j) {
                    TreeNode* node = new TreeNode(0);
                    node->left = left[i];
                    node->right = right[j];
                    temp.push_back(node);
                    
                }
        }
        return temp;
    }
};
```







#### 1123.最深叶结点的最近公共祖先

https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/

| 3.1                                  |      |      |      |      |      |
| ------------------------------------ | ---- | ---- | ---- | ---- | ---- |
| 自己做出来，和答案不同，答案更为巧妙 |      |      |      |      |      |

3.1 先分两步，首先找到最深叶结点，利用BFS；其找到这些节点的最近公共祖先，参考之前写的找到最近公共祖先的题

```c++
class Solution {
public:
// 先分两步，首先找到最深叶结点，利用BFS；其找到这些节点的最近公共祖先
    TreeNode* lcaDeepestLeaves(TreeNode* root) {
        if (root == nullptr)    return nullptr;
        queue<TreeNode*> q, copy;
        q.push(root);
        while (!q.empty()) {
            copy = queue(q);
            int size = q.size();
            while (size--) {
                TreeNode* node = q.front();
                q.pop();
                if (node->left) q.push(node->left);
                if (node->right)    q.push(node->right);
            }
        }
        unordered_map<TreeNode*, int> dict;
        while(!copy.empty()) {
            dict[copy.front()]++;
            copy.pop();
        }
        return lowestCommonAncestor(root, dict);
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, unordered_map<TreeNode*, int>& dict) {
        if (root == nullptr)    return nullptr;
        if (dict.count(root))   return root;

        TreeNode* left = lowestCommonAncestor(root->left, dict);
        TreeNode* right = lowestCommonAncestor(root->right, dict);
        if (left == nullptr)    return right;
        if (right == nullptr)   return left;
        return root;
    }
};
```

更为清晰的方法，最深叶结点的祖先具有的特点，左右子树高度相等，如果不等，说明结果在高的子树里面：

```c++
class Solution {
public:
    TreeNode* lcaDeepestLeaves(TreeNode* root) {
        if (root == nullptr)    return nullptr;
        int left = len_tree(root->left);
        int right = len_tree(root->right);

        if (left == right) 
            return root;
        else if (left > right)
            return lcaDeepestLeaves(root->left);
        else    
            return lcaDeepestLeaves(root->right);
    }

    int len_tree(TreeNode* root) {
        if (root == nullptr)    return 0;
        return max(len_tree(root->left), len_tree(root->right)) + 1;
    }
};
```

此时存在多次重复计算子树深度的问题，将递归求解与递归求高度融合一起.





#### 1315.最深叶结点的最近公共祖先

https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/

| 3.1        |      |      |      |      |      |
| ---------- | ---- | ---- | ---- | ---- | ---- |
| 自己做出来 |      |      |      |      |      |

3.1 祖父节点，其实也就是看 值为偶数的节点的孙子节点 是否存在 孙子节点有四个

```c++
class Solution {
public:
// 祖父节点，其实也就是看 值为偶数的节点的孙子节点 是否存在 孙子节点有四个
    int sumEvenGrandparent(TreeNode* root) {
        int val_sum = 0;
        dfs(root, val_sum);
        return val_sum;
    }

    void dfs(TreeNode* root, int& val_sum) {
        if (root == NULL) return;
        
        if (root->val % 2 == 0) {
            if (root->left) {
                if (root->left->left)   val_sum += root->left->left->val;
                if (root->left->right)   val_sum += root->left->right->val;
            }
            if (root->right) {
                if (root->right->left)   val_sum += root->right->left->val;
                if (root->right->right)   val_sum += root->right->right->val;
            }   
        }
 
        if (root->left)     dfs(root->left, val_sum);
        if (root->right)    dfs(root->right, val_sum);

    }
};
```





#### 235.二叉搜索树的最近公共祖先

https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |

与后面一题的区别，此处借助二叉搜索的特点，就更能找到p、q的分布

后面一题则需要不断后续遍历的方式，找到对应的节点在哪，并不断返回直到出现分布符合不在同一侧的情况。

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL)   return NULL;
        if (p->val > root->val && q->val > root->val)
            return lowestCommonAncestor(root->right, p, q);
        else if (p->val < root->val && q->val < root->val)
            return lowestCommonAncestor(root->left, p, q);
        else
            return root; // 分散两边 或者 出现p、q其中一个在root上，另一个在左、右子树 
        
    }
};
```



#### 236.二叉树的最近公共祖先

https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |

见上一题对比。一般二叉树无法预知节点的分布，故不能采用二叉搜索树中不断逼近的方法，此时只能遍历来找值，一旦找到就不断返回节点的指针，根据两个指针在树中的位置来判断关系。同侧时，找到在上面的节点。不同侧时找到最近的公共节点。

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL)   return NULL;
        if (root->val == p->val || root->val == q->val) return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left == NULL)   return right;
        if (right == NULL)  return left;
        return root;
        
    }
};
```





#### 96.不同的二叉搜索树

https://leetcode-cn.com/problems/unique-binary-search-trees/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |

这一题与下面一题类似，但是这题没有必要遍历路径，相对的，可以由下一题实际遍历的思路来直接计算结果。相反，也可以用本题来指导下一题

找到关系后，应该看出来是有重复子问题的，故使用动态规划

![image-20210301203342725](https://cdn.jsdelivr.net/gh/BigHuang66/picBed@main/img/20210301203342.png)

```c++
class Solution {
public:
// 利用中间节点进行分割找到关系，利用动态规划分别来求
    int numTrees(int n) {
        vector<int> dp = vector<int>(n+1, 0);
        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2; i <= n; ++i)
            for (int j = 1; j <= i; ++j)
                dp[i] += dp[j-1]*dp[i-j];

        return dp[n];
    }
};
```





#### 97.不同的二叉搜索树II

https://leetcode-cn.com/problems/unique-binary-search-trees-ii/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |



```c++
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        return buildTree(1, n);
    }

    vector<TreeNode*> buildTree(int left, int right) {
        if (left > right)
            return {nullptr};
        vector<TreeNode*> temp;
        for (int i = left; i <= right; ++i) {
            vector<TreeNode*> left_list = buildTree(left, i-1);
            vector<TreeNode*> right_list = buildTree(i+1, right);

            for (auto& left: left_list)
                for (auto& right: right_list) {
                    TreeNode* node = new TreeNode(i);
                    node->left = left;
                    node->right = right;
                    temp.emplace_back(node);
                }
        }
        return temp;
    }
};
```





#### 919.完全二叉树插入器

https://leetcode-cn.com/problems/complete-binary-tree-inserter/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |

这种题目一般都是借用成熟的数据结构来构建，树的问题就在于需要递归比价来索引，无法直接得到，可以建立索引对应来完成。

从1开始存入节点，索引为n的节点，其左子节点索引为2n，右子节点索引为2n+1

```c++
class CBTInserter {
public:
// 这种题目一般都是借用成熟的数据结构来构建，树的问题就在于需要递归比价来索引，无法直接得到，可以建立索引对应来完成
    vector<TreeNode*> dict;
    CBTInserter(TreeNode* root) {
        dict.emplace_back(new TreeNode(0));
        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            int size = q.size();
            while(size--) {
                TreeNode* node = q.front();
                dict.emplace_back(node);
                q.pop();
                if (node->left)     q.push(node->left);
                if (node->right)    q.push(node->right);
            }
        }
    }
    
    int insert(int v) {
        TreeNode* node = new TreeNode(v);
        dict.emplace_back(node);
        int index = dict.size() - 1;
        int f_index = index / 2;
        if (index % 2)
            dict[f_index]->right = node;
        else
            dict[f_index]->left = node;
        return dict[f_index]->val;
    }
    
    TreeNode* get_root() {
        if (dict.size() == 1) // 此题可以不加，加上防止索引为空时索引溢出
            return NULL;
        return dict[1];
    }
};
```





# 区间问题



#### 56.合并区间

https://leetcode-cn.com/problems/merge-intervals/

| 3.2      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 自己做的 |      |      |      |      |      |

先排序，可以考虑下有没有必要排序第二个元素。维护一个最长区间，依次拿区间进行对比，分析清楚包含、相交、分离的三种情况。

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> ans;
        sort(intervals.begin(), intervals.end());

        vector<int> max_inter = intervals[0];
        for (int i = 1; i < intervals.size(); ++i) {
            // if (max_inter[1] >= intervals[i][1])
            //     continue;
            if (max_inter[1] >= intervals[i][0] && max_inter[1] < intervals[i][1]) // 第二个字符可以不排序，包含在这里
                max_inter[1] = intervals[i][1];
            else if (max_inter[1] < intervals[i][0]) {
                ans.push_back(max_inter);
                max_inter = intervals[i];
            }
        }
        ans.push_back(max_inter);
        return ans;

    }
};
```





#### 57.插入区间

[57. 插入区间 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/insert-interval/)

| 3.2      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参考答案 |      |      |      |      |      |

 最笨的方法：相当于按照56题的，插入以及重新排序

 优化的方法：抓住原本无重叠且有序，根据插入的区间来选择合适的插入位置，减少排序消耗

![image-20210302151338779](https://cdn.jsdelivr.net/gh/BigHuang66/picBed@main/img/20210302151338.png)

```c++
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        vector<vector<int>> ans;
        
        int i = 0;
        int size = intervals.size();
        // 在待插入区间左边的 只看待插入左边界
        while (i < size && intervals[i][1] < newInterval[0]) {
            ans.push_back(intervals[i]);
            i++;
        }
		// 与待插入区间存在交叉区域 只看待插入右边界
        while (i < size && intervals[i][0] <= newInterval[1]) {
            newInterval[0] = min(newInterval[0], intervals[i][0]);
            newInterval[1] = max(newInterval[1], intervals[i][1]);
            i++;
        }
        ans.push_back(newInterval);
		// 待插入区间右边的
        while (i < size) {
            ans.push_back(intervals[i]);
            i++;
        }
        return ans;
    }
};
```







#### 1288.删除被覆盖区间

[1288. 删除被覆盖区间 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/remove-covered-intervals/)

| 3.2      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参考答案 |      |      |      |      |      |

和上面题目类似思路，但是直接累计结果就好了，注意排序得首位从小到大，末尾从大到小的方式，这样不会丢失被覆盖的区间，当区间完全被覆盖时count++

![image-20210302151338779](https://cdn.jsdelivr.net/gh/BigHuang66/picBed@main/img/20210302151338.png)



```c++
class Solution {
public:
    static bool compare(vector<int>& a, vector<int>& b) {
        if (a[0] == b[0])
            return a[1] > b[1];
        return a[0] < b[0];
    }

    int removeCoveredIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), compare);

        int remove = 0;
        vector<int>& max_inter = intervals[0];
        for(int i = 1; i < intervals.size(); ++i) {
            if (intervals[i][1] <= max_inter[1])
                remove++;
            else if (max_inter[1] >= intervals[i][0] && max_inter[1] < intervals[i][1])
                max_inter[1] = intervals[i][1];
            else if (max_inter[1] < intervals[i][0])
                max_inter = intervals[i];
        }
        return intervals.size()-remove;
    }
};
```





#### 288.汇总区件

[228. 汇总区间 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/summary-ranges/)

| 3.2    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 自己做 |      |      |      |      |      |

遍历更新就好了

```c++
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        if (nums.empty())   return {};

        vector<string> ans;
        vector<int> inter(2, nums[0]);

        for(int i = 0; i < nums.size()-1; ++i) {
            if (nums[i] + 1 == nums[i+1])
                inter[1] = nums[i+1];
            else {
                if (inter[0] == inter[1])
                    ans.emplace_back(to_string(inter[0]));
                else
                    ans.emplace_back(to_string(inter[0]) + "->" + to_string(inter[1]));
                inter[0] = nums[i+1];
                inter[1] = nums[i+1];
            }
        }
        if (inter[0] == inter[1])
            ans.emplace_back(to_string(inter[0]));
        else
            ans.emplace_back(to_string(inter[0]) + "->" + to_string(inter[1]));
        return ans;
    }
};
```





#### 986.区间列表的交集

[986. 区间列表的交集 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/interval-list-intersections/)

|      | 3.2          |      |      |      |      |
| ---- | ------------ | ---- | ---- | ---- | ---- |
|      | 参考历史记录 |      |      |      |      |

有点NMS的意味，分别各拿一个，算重合区间，存在则记录，否则看谁长，选短的那一端递增。

```c++
class Solution {
public:
    vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList, vector<vector<int>>& secondList) {
        vector<vector<int>> ans;
        int size1 = firstList.size(), size2 = secondList.size();
        int i = 0, j = 0;
        while (i < size1 && j < size2) {
            vector<int>& a = firstList[i];
            vector<int>& b = secondList[j];
            int left = max(a[0], b[0]);
            int right = min(a[1], b[1]);
            if (right - left >= 0)
                ans.emplace_back(vector<int>{left, right});
                // cout << left << right << endl;
            if (b[1] > a[1])
                i++;
            else
                j++;
        }
        return ans;
    }
};
```





#### 435.无重叠区间

[435. 无重叠区间 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/non-overlapping-intervals/)

| 3.2          |      |      |      |      |      |
| ------------ | ---- | ---- | ---- | ---- | ---- |
| 参考历史记录 |      |      |      |      |      |

贪心算法，有重合时应该尽量去除右边界长的（保留右边界小的）。

```c++
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.empty())  return 0;

        sort(intervals.begin(), intervals.end());
        int end = intervals[0][1];
        int count = 0;
        
        for(int i = 1; i < intervals.size(); ++i) {
            if (intervals[i][0] < end) {
                end = min(intervals[i][1], end);
                count++;
            } else
                end = intervals[i][1];
        }
        return count;
    }
};
```







#### 795.区间子数组个数

[795. 区间子数组个数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum/)

| 3.2      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 看答案的 |      |      |      |      |      |

首先是组合的数目采用 前N项和计算；其次是利用集合相减的方式来计算中间集合的大小。

```c++
class Solution {
public:
    int numSubarrayBoundedMax(vector<int>& A, int L, int R) {
        return countN(A, R) - countN(A, L-1);
    }

    int countN(vector<int>& A, int T) {
        int count = 0;
        int value = 0;
        for (int n:A) {
            value = n <= T ? value+1 : 0;
            count += value;
        }
        return count;
    }
};
```









# 回溯算法

## 总结：

```python
#**************************** 回溯算法框架 ***********************************

# ** 注意回溯 实际问题要适当 剪枝减低计算量；要经常结合树图分析**
	result = []
    def backtrack(路径, 路径列表):
        if 满足结束条件:
            result.add(路径)
            return
        # 做选择
        路径.add()
        # 遍历
        backtrack(路径, 路径列表)
       	# 撤销选择
        路径.del()
```

具体可能遇到以下问题：

![](https://cdn.jsdelivr.net/gh/BigHuang66/picBed@main/img/20210303112953.svg)



#### 39.组合总和

[39. 组合总和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/combination-sum/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 看答案 |      |      |      |      |      |

首先求解目标和 target的问题，注意用减法，避免引入 加法做和 

其次得注意这是组合问题，参照组合问题特性解决。

本题可以重复使用元素，维护begin，每次从 i 开始做选择就好，这时包含了本身

本类型题目注意剪枝，明确不满足条件没必要带入递归当中，但是注意本题要想直接break，需要先排序

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<int> path;
        sort(candidates.begin(), candidates.end());
        backtrack(candidates, 0, target, path);
        return ans;

    }

    void backtrack(vector<int>& candidates, int begin, int target, vector<int>& path) {
        if (target == 0) {
            ans.emplace_back(path);
            return;
        } else if (target < 0)
            return;
        // 做选择
        for (int i = begin; i < candidates.size(); ++i) {
            if (target-candidates[i] < 0) // 剪枝，因为已经排序了，前面为负，后面肯定更是
                break;
            path.push_back(candidates[i]);
            backtrack(candidates, i, target-candidates[i], path);
            path.pop_back();
        }       
    }
};
```







#### 40.组合总和 II

[40. 组合总和 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/combination-sum-ii/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 看答案 |      |      |      |      |      |

39题基础上，元素只能使用一次，存在重复元素等两个问题，可以按照思维导图分别实现。

只能使用一次的问题，使用begin = i + 1实现就好；重复元素问题 排序、维护visited、if (i>0 && !visited[i] && nums[i] == nums[i-1])

```c++
class Solution {
public:
// 这一题相对于 39题 多了重复元素的问题，可以先排序+visited解决
    vector<vector<int>> ans;
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<int> path;
        vector<bool> visited(candidates.size(), false);
        sort(candidates.begin(), candidates.end());
        backtrack(candidates, visited, 0, target, path);
        return ans;

    }

    void backtrack(vector<int>& candidates, vector<bool>& visited, int begin, int target, vector<int>& path) {
        if (target == 0) {
            ans.emplace_back(path);
            return;
        } else if (target < 0)
            return;
        
        for (int i = begin; i < candidates.size(); ++i) {
            if (target - candidates[i] < 0) // 剪枝
                break;
            // if (visited[i] == true) // 此处与下面i+1 相对，原理都为避免范围重复元素 选一个即可
            //     continue;
            if (i > 0 && !visited[i-1] && candidates[i] == candidates[i-1])
                continue;
            
            visited[i] = true;
            path.push_back(candidates[i]);
            backtrack(candidates, visited, i+1, target-candidates[i], path);
            visited[i] = false;
            path.pop_back();
        }
    }
};
```









#### 216.组合总和 III

[216. 组合总和 III - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/combination-sum-iii/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 看答案 |      |      |      |      |      |

这一题似乎是个九叉树的问题，开始被 k 弄晕，本以为要循环3次，每次从1~9中间取值......最后发现完全可以直接遍历1~9 直到 path长度等于 k 就好了，从终止条件来约束遍历的过程。

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<int> path;
        vector<bool> visited(k, false);
        backtrack(k, n, 1, visited, path);
        return ans;
    }

    void backtrack(int k, int n, int begin, vector<bool>& visited, vector<int>& path) {
        if (n == 0 && path.size() == k) {
            ans.emplace_back(path);
            return;
        } else if (n < 0)
            return;

        for (int i = begin; i <= 9; ++i) {
            if (n - i < 0)  break;
            if (visited[i-1])
                continue;
            path.push_back(i);
            visited[i-1] = true;
            backtrack(k, n-i, i, visited, path);
            path.pop_back();
            visited[i-1] = false;
        }
    }
};
```









#### 78.子集

[78. 子集 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/subsets/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 看答案 |      |      |      |      |      |

子集问题，避免排列重复的情况，引入begin来限制 做选择 的起点。同时做一次选择就可以视为一个子集读入，注意空集合也是子集。

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<int> path;
        ans.push_back({});
        backtrack(nums, 0, path);
        return ans;
    }

    void backtrack(vector<int>& nums, int begin, vector<int>& path) {
        if (begin == nums.size()) {
            return;
        }

        for (int i = begin; i < nums.size(); ++i) {
            path.push_back(nums[i]);
            ans.emplace_back(path);
            backtrack(nums, i+1, path);
            path.pop_back();
        }
    }
};
```







#### 90.子集 II

[90. 子集 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/subsets-ii/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 看答案 |      |      |      |      |      |

可能包含重复元素的子集问题，在子集问题基础上剪枝，主要剪掉重复元素的问题。维护visited，使用 if (i >0 && !visited[i-1] && nums[i]==nums[i-1]) 

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<int> path;
        vector<bool> visited(nums.size(), false);
        ans.push_back({});
        sort(nums.begin(), nums.end());
        backtrack(nums, visited, 0, path);
        return ans;
    }

    void backtrack(vector<int>& nums, vector<bool>& visited, int begin, vector<int>& path) {
        if (begin == nums.size())
            return;
        
        for (int i = begin; i < nums.size(); ++i) {
            if (i > 0 && !visited[i-1] && nums[i] == nums[i-1])
                continue;
            path.push_back(nums[i]);
            visited[i] = true;
            ans.emplace_back(path);
            backtrack(nums, visited, i+1, path);
            path.pop_back();
            visited[i] = false;
        }
    }
};
```







#### 46.全排列

[46. 全排列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/permutations/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 自己做 |      |      |      |      |      |

全排列问题，每一层从头做选择，但是需要维护 visited 来防止重复元素

```c++
// 全排列问题用回溯算法解决
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> permute(vector<int>& nums) {
        vector<int> path;
        vector<bool> visited(nums.size(), false);
        backtrack(nums, visited, path);
        return ans;
    }
    void backtrack(vector<int>& nums, vector<bool>& visited, vector<int>& path) {
        // 结束条件
        if (path.size() == nums.size()) {
            ans.emplace_back(path);
            return ;
        }

        for (int i = 0; i < nums.size(); ++i) {
            // nums[i] already visited, then continue
            if (visited[i])
                continue;
            path.push_back(nums[i]);
            visited[i] = true;
            backtrack(nums, visited, path);
            path.pop_back();
            visited[i] = false;
        }

    }
};
```







#### 47.全排列 II

[47. 全排列 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/permutations-ii/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 自己做 |      |      |      |      |      |

包含重复元素的全排列问题，维护 visited 和 if(i>0 && !visited[i-1] && nums[i] == nums[i-1])

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<int> path;
        vector<bool> visited(nums.size(), false);
        sort(nums.begin(), nums.end());
        backtrack(nums, visited, path);
        return ans;
    }

    void backtrack(vector<int>& nums, vector<bool>& visited, vector<int>& path) {
        if (path.size() == nums.size()) {
            ans.emplace_back(path);
            return;
        }

        for (int i = 0; i < nums.size(); ++i) {
            if (visited[i])
                continue;
            
            if (i > 0 && !visited[i-1] && nums[i]==nums[i-1])
                continue;
            path.push_back(nums[i]);
            visited[i] = true;
            backtrack(nums, visited, path);
            path.pop_back();
            visited[i] = false;
        }
    }
};
```









#### 131.分割回文串

[131. 分割回文串 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/palindrome-partitioning/)

| 3.3      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参考档案 |      |      |      |      |      |

利用 begin 和 i 类似于作为双指针的方式来不断截取字符串，重点是终止条件

```c++
class Solution {
public:
    vector<vector<string>> ans;
    vector<vector<string>> partition(string s) {
        vector<string> path;
        backtrack(s, 0, path);
        return ans;
    }
    void backtrack(string& s, int begin, vector<string>& path) {
        if (begin == s.size()) {
            ans.emplace_back(path);
            return;
        }

        for (int i = begin; i < s.size(); ++i) {
            if (!check(s, begin, i))
                continue;
            path.emplace_back(s.substr(begin, i-begin+1));
            backtrack(s, i+1, path);
            path.pop_back();
        }
    }

    bool check(string& s, int left, int right) {
        while (left < right) {
            if (s[left] != s[right])
                return false;
            left++;
            right--;
        }
        return true;
    }
};
```









#### 93.复原IP地址

[93. 复原 IP 地址 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/restore-ip-addresses/)

| 3.3    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 自己做 |      |      |      |      |      |

和上一题有点像的，其实也属于字符串的分段，不够得加好剪枝与合法性判断

```c++
class Solution {
public:
    vector<string> ans;
    vector<string> restoreIpAddresses(string s) {
        string path;
        backtrack(s, 0, 0, path);
        return ans;
    }

    void backtrack(string& s, int begin, int section, string& path) {
        if (path.size() == s.size() + 4 && section == 4) { // 所得长度刚好为s+4(4个点) 且分区必须满足 4
            path.pop_back();                               // 可以不需要 == 4 之前已经被剪枝了，不可能满足长度相等情况下还分区不同。
            ans.emplace_back(path);                        // 如果没有对分区剪枝，可能会出现许多小数点填补导致长度相等
            return;
        }

        for (int i = begin; i < s.size(); ++i) {
            if (section > 3) // 分片超过四个了，剪枝
                break;
            if (i-begin >= 1 && s[begin] == '0') // 长度(i-begin+1) 大于一个，且以0开头，如果出现，后面必不可得到，剪枝  
                break;
            if (stoi(s.substr(begin, i-begin+1)) > 255) // 分片数值大于255， 剪枝
                break;
            
            string temp = path;                         // 便于撤销选择
            path += (s.substr(begin, i-begin+1) + ".");
            backtrack(s, i+1, section+1, path);
            path = temp;
        }
    }
};
```

