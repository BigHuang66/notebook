# 链表



# 二叉树

#### 894.所有可能的满二叉树 

https://leetcode-cn.com/problems/all-possible-full-binary-trees/

| 3.1    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 看答案 |      |      |      |      |      |

3.1 本题最开始拿到时，考虑的方法是利用DFS来进行回溯，但是结果发现回溯时，每次撤销导致有情况丢失。看答案如下，本质还是递归，不过用了排列组合的思想：

```c++
class Solution {
public:
    vector<TreeNode*> allPossibleFBT(int N) {
        vector<TreeNode*> temp;
        if (N == 0) return temp;
        if (N % 2 == 0)  return temp;
        if (N == 1) {
            temp.push_back(new TreeNode(0));
            return temp;
        }
        // 分别分奇数构建左右子树
        for (int i = 1; i < N-1; i+=2) {
            vector<TreeNode*> left = allPossibleFBT(i);
            vector<TreeNode*> right = allPossibleFBT(N-1-i);
			// 排列组合
            for (int i = 0; i < left.size(); ++i)
                for (int j = 0; j < right.size(); ++j) {
                    TreeNode* node = new TreeNode(0);
                    node->left = left[i];
                    node->right = right[j];
                    temp.push_back(node);
                    
                }
        }
        return temp;
    }
};
```







#### 1123.最深叶结点的最近公共祖先

https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/

| 3.1                                  |      |      |      |      |      |
| ------------------------------------ | ---- | ---- | ---- | ---- | ---- |
| 自己做出来，和答案不同，答案更为巧妙 |      |      |      |      |      |

3.1 先分两步，首先找到最深叶结点，利用BFS；其找到这些节点的最近公共祖先，参考之前写的找到最近公共祖先的题

```c++
class Solution {
public:
// 先分两步，首先找到最深叶结点，利用BFS；其找到这些节点的最近公共祖先
    TreeNode* lcaDeepestLeaves(TreeNode* root) {
        if (root == nullptr)    return nullptr;
        queue<TreeNode*> q, copy;
        q.push(root);
        while (!q.empty()) {
            copy = queue(q);
            int size = q.size();
            while (size--) {
                TreeNode* node = q.front();
                q.pop();
                if (node->left) q.push(node->left);
                if (node->right)    q.push(node->right);
            }
        }
        unordered_map<TreeNode*, int> dict;
        while(!copy.empty()) {
            dict[copy.front()]++;
            copy.pop();
        }
        return lowestCommonAncestor(root, dict);
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, unordered_map<TreeNode*, int>& dict) {
        if (root == nullptr)    return nullptr;
        if (dict.count(root))   return root;

        TreeNode* left = lowestCommonAncestor(root->left, dict);
        TreeNode* right = lowestCommonAncestor(root->right, dict);
        if (left == nullptr)    return right;
        if (right == nullptr)   return left;
        return root;
    }
};
```

更为清晰的方法，最深叶结点的祖先具有的特点，左右子树高度相等，如果不等，说明结果在高的子树里面：

```c++
class Solution {
public:
    TreeNode* lcaDeepestLeaves(TreeNode* root) {
        if (root == nullptr)    return nullptr;
        int left = len_tree(root->left);
        int right = len_tree(root->right);

        if (left == right) 
            return root;
        else if (left > right)
            return lcaDeepestLeaves(root->left);
        else    
            return lcaDeepestLeaves(root->right);
    }

    int len_tree(TreeNode* root) {
        if (root == nullptr)    return 0;
        return max(len_tree(root->left), len_tree(root->right)) + 1;
    }
};
```

此时存在多次重复计算子树深度的问题，将递归求解与递归求高度融合一起.





#### 1315.最深叶结点的最近公共祖先

https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/

| 3.1        |      |      |      |      |      |
| ---------- | ---- | ---- | ---- | ---- | ---- |
| 自己做出来 |      |      |      |      |      |

3.1 祖父节点，其实也就是看 值为偶数的节点的孙子节点 是否存在 孙子节点有四个

```c++
class Solution {
public:
// 祖父节点，其实也就是看 值为偶数的节点的孙子节点 是否存在 孙子节点有四个
    int sumEvenGrandparent(TreeNode* root) {
        int val_sum = 0;
        dfs(root, val_sum);
        return val_sum;
    }

    void dfs(TreeNode* root, int& val_sum) {
        if (root == NULL) return;
        
        if (root->val % 2 == 0) {
            if (root->left) {
                if (root->left->left)   val_sum += root->left->left->val;
                if (root->left->right)   val_sum += root->left->right->val;
            }
            if (root->right) {
                if (root->right->left)   val_sum += root->right->left->val;
                if (root->right->right)   val_sum += root->right->right->val;
            }   
        }
 
        if (root->left)     dfs(root->left, val_sum);
        if (root->right)    dfs(root->right, val_sum);

    }
};
```





#### 235.二叉搜索树的最近公共祖先

https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |

与后面一题的区别，此处借助二叉搜索的特点，就更能找到p、q的分布

后面一题则需要不断后续遍历的方式，找到对应的节点在哪，并不断返回直到出现分布符合不在同一侧的情况。

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL)   return NULL;
        if (p->val > root->val && q->val > root->val)
            return lowestCommonAncestor(root->right, p, q);
        else if (p->val < root->val && q->val < root->val)
            return lowestCommonAncestor(root->left, p, q);
        else
            return root; // 分散两边 或者 出现p、q其中一个在root上，另一个在左、右子树 
        
    }
};
```



#### 236.二叉树的最近公共祖先

https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |

见上一题对比。一般二叉树无法预知节点的分布，故不能采用二叉搜索树中不断逼近的方法，此时只能遍历来找值，一旦找到就不断返回节点的指针，根据两个指针在树中的位置来判断关系。同侧时，找到在上面的节点。不同侧时找到最近的公共节点。

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL)   return NULL;
        if (root->val == p->val || root->val == q->val) return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left == NULL)   return right;
        if (right == NULL)  return left;
        return root;
        
    }
};
```

