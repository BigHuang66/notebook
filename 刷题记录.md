# 链表



# 二叉树

#### 894.所有可能的满二叉树 

https://leetcode-cn.com/problems/all-possible-full-binary-trees/

| 3.1    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 看答案 |      |      |      |      |      |

3.1 本题最开始拿到时，考虑的方法是利用DFS来进行回溯，但是结果发现回溯时，每次撤销导致有情况丢失。看答案如下，本质还是递归，不过用了排列组合的思想：

```c++
class Solution {
public:
    vector<TreeNode*> allPossibleFBT(int N) {
        vector<TreeNode*> temp;
        if (N == 0) return temp;
        if (N % 2 == 0)  return temp;
        if (N == 1) {
            temp.push_back(new TreeNode(0));
            return temp;
        }
        // 分别分奇数构建左右子树
        for (int i = 1; i < N-1; i+=2) {
            vector<TreeNode*> left = allPossibleFBT(i);
            vector<TreeNode*> right = allPossibleFBT(N-1-i);
			// 排列组合
            for (int i = 0; i < left.size(); ++i)
                for (int j = 0; j < right.size(); ++j) {
                    TreeNode* node = new TreeNode(0);
                    node->left = left[i];
                    node->right = right[j];
                    temp.push_back(node);
                    
                }
        }
        return temp;
    }
};
```







#### 1123.最深叶结点的最近公共祖先

https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/

| 3.1                                  |      |      |      |      |      |
| ------------------------------------ | ---- | ---- | ---- | ---- | ---- |
| 自己做出来，和答案不同，答案更为巧妙 |      |      |      |      |      |

3.1 先分两步，首先找到最深叶结点，利用BFS；其找到这些节点的最近公共祖先，参考之前写的找到最近公共祖先的题

```c++
class Solution {
public:
// 先分两步，首先找到最深叶结点，利用BFS；其找到这些节点的最近公共祖先
    TreeNode* lcaDeepestLeaves(TreeNode* root) {
        if (root == nullptr)    return nullptr;
        queue<TreeNode*> q, copy;
        q.push(root);
        while (!q.empty()) {
            copy = queue(q);
            int size = q.size();
            while (size--) {
                TreeNode* node = q.front();
                q.pop();
                if (node->left) q.push(node->left);
                if (node->right)    q.push(node->right);
            }
        }
        unordered_map<TreeNode*, int> dict;
        while(!copy.empty()) {
            dict[copy.front()]++;
            copy.pop();
        }
        return lowestCommonAncestor(root, dict);
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, unordered_map<TreeNode*, int>& dict) {
        if (root == nullptr)    return nullptr;
        if (dict.count(root))   return root;

        TreeNode* left = lowestCommonAncestor(root->left, dict);
        TreeNode* right = lowestCommonAncestor(root->right, dict);
        if (left == nullptr)    return right;
        if (right == nullptr)   return left;
        return root;
    }
};
```

更为清晰的方法，最深叶结点的祖先具有的特点，左右子树高度相等，如果不等，说明结果在高的子树里面：

```c++
class Solution {
public:
    TreeNode* lcaDeepestLeaves(TreeNode* root) {
        if (root == nullptr)    return nullptr;
        int left = len_tree(root->left);
        int right = len_tree(root->right);

        if (left == right) 
            return root;
        else if (left > right)
            return lcaDeepestLeaves(root->left);
        else    
            return lcaDeepestLeaves(root->right);
    }

    int len_tree(TreeNode* root) {
        if (root == nullptr)    return 0;
        return max(len_tree(root->left), len_tree(root->right)) + 1;
    }
};
```

此时存在多次重复计算子树深度的问题，将递归求解与递归求高度融合一起.





#### 1315.最深叶结点的最近公共祖先

https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/

| 3.1        |      |      |      |      |      |
| ---------- | ---- | ---- | ---- | ---- | ---- |
| 自己做出来 |      |      |      |      |      |

3.1 祖父节点，其实也就是看 值为偶数的节点的孙子节点 是否存在 孙子节点有四个

```c++
class Solution {
public:
// 祖父节点，其实也就是看 值为偶数的节点的孙子节点 是否存在 孙子节点有四个
    int sumEvenGrandparent(TreeNode* root) {
        int val_sum = 0;
        dfs(root, val_sum);
        return val_sum;
    }

    void dfs(TreeNode* root, int& val_sum) {
        if (root == NULL) return;
        
        if (root->val % 2 == 0) {
            if (root->left) {
                if (root->left->left)   val_sum += root->left->left->val;
                if (root->left->right)   val_sum += root->left->right->val;
            }
            if (root->right) {
                if (root->right->left)   val_sum += root->right->left->val;
                if (root->right->right)   val_sum += root->right->right->val;
            }   
        }
 
        if (root->left)     dfs(root->left, val_sum);
        if (root->right)    dfs(root->right, val_sum);

    }
};
```





#### 235.二叉搜索树的最近公共祖先

https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |

与后面一题的区别，此处借助二叉搜索的特点，就更能找到p、q的分布

后面一题则需要不断后续遍历的方式，找到对应的节点在哪，并不断返回直到出现分布符合不在同一侧的情况。

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL)   return NULL;
        if (p->val > root->val && q->val > root->val)
            return lowestCommonAncestor(root->right, p, q);
        else if (p->val < root->val && q->val < root->val)
            return lowestCommonAncestor(root->left, p, q);
        else
            return root; // 分散两边 或者 出现p、q其中一个在root上，另一个在左、右子树 
        
    }
};
```



#### 236.二叉树的最近公共祖先

https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |

见上一题对比。一般二叉树无法预知节点的分布，故不能采用二叉搜索树中不断逼近的方法，此时只能遍历来找值，一旦找到就不断返回节点的指针，根据两个指针在树中的位置来判断关系。同侧时，找到在上面的节点。不同侧时找到最近的公共节点。

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL)   return NULL;
        if (root->val == p->val || root->val == q->val) return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left == NULL)   return right;
        if (right == NULL)  return left;
        return root;
        
    }
};
```





#### 96.不同的二叉搜索树

https://leetcode-cn.com/problems/unique-binary-search-trees/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |

这一题与下面一题类似，但是这题没有必要遍历路径，相对的，可以由下一题实际遍历的思路来直接计算结果。相反，也可以用本题来指导下一题

找到关系后，应该看出来是有重复子问题的，故使用动态规划

![image-20210301203342725](https://cdn.jsdelivr.net/gh/BigHuang66/picBed@main/img/20210301203342.png)

```c++
class Solution {
public:
// 利用中间节点进行分割找到关系，利用动态规划分别来求
    int numTrees(int n) {
        vector<int> dp = vector<int>(n+1, 0);
        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2; i <= n; ++i)
            for (int j = 1; j <= i; ++j)
                dp[i] += dp[j-1]*dp[i-j];

        return dp[n];
    }
};
```





#### 97.不同的二叉搜索树II

https://leetcode-cn.com/problems/unique-binary-search-trees-ii/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |



```c++
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        return buildTree(1, n);
    }

    vector<TreeNode*> buildTree(int left, int right) {
        if (left > right)
            return {nullptr};
        vector<TreeNode*> temp;
        for (int i = left; i <= right; ++i) {
            vector<TreeNode*> left_list = buildTree(left, i-1);
            vector<TreeNode*> right_list = buildTree(i+1, right);

            for (auto& left: left_list)
                for (auto& right: right_list) {
                    TreeNode* node = new TreeNode(i);
                    node->left = left;
                    node->right = right;
                    temp.emplace_back(node);
                }
        }
        return temp;
    }
};
```





#### 919.完全二叉树插入器

https://leetcode-cn.com/problems/complete-binary-tree-inserter/

| 3.1      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参看答案 |      |      |      |      |      |

这种题目一般都是借用成熟的数据结构来构建，树的问题就在于需要递归比价来索引，无法直接得到，可以建立索引对应来完成。

从1开始存入节点，索引为n的节点，其左子节点索引为2n，右子节点索引为2n+1

```c++
class CBTInserter {
public:
// 这种题目一般都是借用成熟的数据结构来构建，树的问题就在于需要递归比价来索引，无法直接得到，可以建立索引对应来完成
    vector<TreeNode*> dict;
    CBTInserter(TreeNode* root) {
        dict.emplace_back(new TreeNode(0));
        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            int size = q.size();
            while(size--) {
                TreeNode* node = q.front();
                dict.emplace_back(node);
                q.pop();
                if (node->left)     q.push(node->left);
                if (node->right)    q.push(node->right);
            }
        }
    }
    
    int insert(int v) {
        TreeNode* node = new TreeNode(v);
        dict.emplace_back(node);
        int index = dict.size() - 1;
        int f_index = index / 2;
        if (index % 2)
            dict[f_index]->right = node;
        else
            dict[f_index]->left = node;
        return dict[f_index]->val;
    }
    
    TreeNode* get_root() {
        if (dict.size() == 1) // 此题可以不加，加上防止索引为空时索引溢出
            return NULL;
        return dict[1];
    }
};
```





# 区间问题



#### 56.合并区间

https://leetcode-cn.com/problems/merge-intervals/

| 3.2      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 自己做的 |      |      |      |      |      |

先排序，可以考虑下有没有必要排序第二个元素。维护一个最长区间，依次拿区间进行对比，分析清楚包含、相交、分离的三种情况。

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> ans;
        sort(intervals.begin(), intervals.end());

        vector<int> max_inter = intervals[0];
        for (int i = 1; i < intervals.size(); ++i) {
            // if (max_inter[1] >= intervals[i][1])
            //     continue;
            if (max_inter[1] >= intervals[i][0] && max_inter[1] < intervals[i][1]) // 第二个字符可以不排序，包含在这里
                max_inter[1] = intervals[i][1];
            else if (max_inter[1] < intervals[i][0]) {
                ans.push_back(max_inter);
                max_inter = intervals[i];
            }
        }
        ans.push_back(max_inter);
        return ans;

    }
};
```





#### 57.插入区间

[57. 插入区间 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/insert-interval/)

| 3.2      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参考答案 |      |      |      |      |      |

 最笨的方法：相当于按照56题的，插入以及重新排序

 优化的方法：抓住原本无重叠且有序，根据插入的区间来选择合适的插入位置，减少排序消耗

![image-20210302151338779](https://cdn.jsdelivr.net/gh/BigHuang66/picBed@main/img/20210302151338.png)

```c++
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        vector<vector<int>> ans;
        
        int i = 0;
        int size = intervals.size();
        // 在待插入区间左边的 只看待插入左边界
        while (i < size && intervals[i][1] < newInterval[0]) {
            ans.push_back(intervals[i]);
            i++;
        }
		// 与待插入区间存在交叉区域 只看待插入右边界
        while (i < size && intervals[i][0] <= newInterval[1]) {
            newInterval[0] = min(newInterval[0], intervals[i][0]);
            newInterval[1] = max(newInterval[1], intervals[i][1]);
            i++;
        }
        ans.push_back(newInterval);
		// 待插入区间右边的
        while (i < size) {
            ans.push_back(intervals[i]);
            i++;
        }
        return ans;
    }
};
```







#### 1288.删除被覆盖区间

[1288. 删除被覆盖区间 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/remove-covered-intervals/)

| 3.2      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 参考答案 |      |      |      |      |      |

和上面题目类似思路，但是直接累计结果就好了，注意排序得首位从小到大，末尾从大到小的方式，这样不会丢失被覆盖的区间，当区间完全被覆盖时count++

![image-20210302151338779](https://cdn.jsdelivr.net/gh/BigHuang66/picBed@main/img/20210302151338.png)



```c++
class Solution {
public:
    static bool compare(vector<int>& a, vector<int>& b) {
        if (a[0] == b[0])
            return a[1] > b[1];
        return a[0] < b[0];
    }

    int removeCoveredIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), compare);

        int remove = 0;
        vector<int>& max_inter = intervals[0];
        for(int i = 1; i < intervals.size(); ++i) {
            if (intervals[i][1] <= max_inter[1])
                remove++;
            else if (max_inter[1] >= intervals[i][0] && max_inter[1] < intervals[i][1])
                max_inter[1] = intervals[i][1];
            else if (max_inter[1] < intervals[i][0])
                max_inter = intervals[i];
        }
        return intervals.size()-remove;
    }
};
```





#### 288.汇总区件

[228. 汇总区间 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/summary-ranges/)

| 3.2    |      |      |      |      |      |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 自己做 |      |      |      |      |      |

遍历更新就好了

```c++
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        if (nums.empty())   return {};

        vector<string> ans;
        vector<int> inter(2, nums[0]);

        for(int i = 0; i < nums.size()-1; ++i) {
            if (nums[i] + 1 == nums[i+1])
                inter[1] = nums[i+1];
            else {
                if (inter[0] == inter[1])
                    ans.emplace_back(to_string(inter[0]));
                else
                    ans.emplace_back(to_string(inter[0]) + "->" + to_string(inter[1]));
                inter[0] = nums[i+1];
                inter[1] = nums[i+1];
            }
        }
        if (inter[0] == inter[1])
            ans.emplace_back(to_string(inter[0]));
        else
            ans.emplace_back(to_string(inter[0]) + "->" + to_string(inter[1]));
        return ans;
    }
};
```





#### 986.区间列表的交集

[986. 区间列表的交集 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/interval-list-intersections/)

|      | 3.2          |      |      |      |      |
| ---- | ------------ | ---- | ---- | ---- | ---- |
|      | 参考历史记录 |      |      |      |      |

有点NMS的意味，分别各拿一个，算重合区间，存在则记录，否则看谁长，选短的那一端递增。

```c++
class Solution {
public:
    vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList, vector<vector<int>>& secondList) {
        vector<vector<int>> ans;
        int size1 = firstList.size(), size2 = secondList.size();
        int i = 0, j = 0;
        while (i < size1 && j < size2) {
            vector<int>& a = firstList[i];
            vector<int>& b = secondList[j];
            int left = max(a[0], b[0]);
            int right = min(a[1], b[1]);
            if (right - left >= 0)
                ans.emplace_back(vector<int>{left, right});
                // cout << left << right << endl;
            if (b[1] > a[1])
                i++;
            else
                j++;
        }
        return ans;
    }
};
```





#### 435.无重叠区间

[435. 无重叠区间 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/non-overlapping-intervals/)

| 3.2          |      |      |      |      |      |
| ------------ | ---- | ---- | ---- | ---- | ---- |
| 参考历史记录 |      |      |      |      |      |

贪心算法，有重合时应该尽量去除右边界长的（保留右边界小的）。

```c++
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.empty())  return 0;

        sort(intervals.begin(), intervals.end());
        int end = intervals[0][1];
        int count = 0;
        
        for(int i = 1; i < intervals.size(); ++i) {
            if (intervals[i][0] < end) {
                end = min(intervals[i][1], end);
                count++;
            } else
                end = intervals[i][1];
        }
        return count;
    }
};
```







#### 795.区间子数组个数

[795. 区间子数组个数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum/)

| 3.2      |      |      |      |      |      |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 看答案的 |      |      |      |      |      |

首先是组合的数目采用 前N项和计算；其次是利用集合相减的方式来计算中间集合的大小。

```c++
class Solution {
public:
    int numSubarrayBoundedMax(vector<int>& A, int L, int R) {
        return countN(A, R) - countN(A, L-1);
    }

    int countN(vector<int>& A, int T) {
        int count = 0;
        int value = 0;
        for (int n:A) {
            value = n <= T ? value+1 : 0;
            count += value;
        }
        return count;
    }
};
```

